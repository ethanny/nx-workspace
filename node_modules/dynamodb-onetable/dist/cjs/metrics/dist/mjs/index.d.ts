export const DefaultSpans: {
    period: number;
    samples: number;
}[];
export class CustomMetrics {
    static terminate(): Promise<void>;
    static flushAll(): Promise<void>;
    static freeInstanceByKey(key: any): void;
    static saveInstance(tags: any, metrics: any): void;
    constructor(options?: {});
    consistent: boolean;
    buffer: any;
    buffers: any;
    client: any;
    expires: any;
    log: Log;
    options: {};
    owner: any;
    prefix: string;
    primaryKey: any;
    sortKey: any;
    pResolution: any;
    source: any;
    spans: any;
    table: any;
    type: any;
    ttl: any;
    emit(namespace: any, metricName: any, value: any, dimensionsList?: {}[], options?: {}): Promise<any>;
    emitDimensions(namespace: any, metricName: any, point: any, dimensionsList: any, options: any): Promise<any>;
    bufferMetric(namespace: any, metricName: any, point: any, dimensions: any, options: any): Promise<any>;
    emitDimensionedMetric(namespace: any, metricName: any, point: any, dimensions: any, options?: {}): Promise<any>;
    upgrade(namespace: any, metricName: any, dimensionsList?: {}[], options?: {}): Promise<any>;
    upgradeMetric(old: any): any;
    flush(): Promise<void>;
    flushElt(elt: any, timestamp: any): Promise<void>;
    getBufferKey(namespace: any, metricName: any, dimensions: any): string;
    query(namespace: any, metricName: any, dimensions: any, period: any, statistic: any, options?: {}): Promise<{
        dimensions: {};
        metric: any;
        namespace: any;
        owner: any;
        period: any;
        points: {
            value: number;
            timestamp: any;
            count: number;
        }[];
        samples: any;
    } | {
        dimensions: {};
        metric: any;
        namespace: any;
        period: any;
        points: {
            value: any;
            count: any;
            timestamp: number;
        }[];
        owner: any;
        samples: any;
    } | {
        dimensions: any;
        id: any;
        metric: any;
        namespace: any;
        period: any;
        points: any[];
        owner: any;
        samples: number;
    }>;
    accumulateMetric(metric: any, span: any, statistic: any, owner: any, start: any, period: any): {
        dimensions: {};
        metric: any;
        namespace: any;
        owner: any;
        period: any;
        points: {
            value: number;
            timestamp: any;
            count: number;
        }[];
        samples: any;
    };
    calculateSeries(metric: any, span: any, statistic: any, owner: any, start: any, period: any): {
        dimensions: {};
        metric: any;
        namespace: any;
        period: any;
        points: {
            value: any;
            count: any;
            timestamp: number;
        }[];
        owner: any;
        samples: any;
    };
    makeDimensionString(dimensions: any): string;
    makeDimensionObject(dimensions: any): {};
    addValue(metric: any, timestamp: any, point: any, si: any, querySpanIndex?: any): void;
    setPoint(span: any, index: any, add: any): void;
    getMetricList(namespace?: any, metric?: any, options?: {
        limit: number;
    }): Promise<{
        namespaces: string[];
    }>;
    initMetric(owner: any, namespace: any, name: any, dimensions: any, timestamp: any): {
        dimensions: any;
        metric: any;
        namespace: any;
        owner: any;
        spans: any[];
        version: number;
    };
    getMetric(owner: any, namespace: any, metric: any, dimensions: any, log: any): Promise<{
        dimensions: any;
        expires: any;
        metric: any;
        namespace: any;
        owner: any;
        seq: any;
        spans: any;
    }>;
    findMetrics(owner: any, namespace: any, metric: any, limit: any, startKey: any): Promise<{
        items: {
            dimensions: any;
            expires: any;
            metric: any;
            namespace: any;
            owner: any;
            seq: any;
            spans: any;
        }[];
        next: Record<string, any>;
        command: QueryCommand;
    }>;
    putMetric(item: any, options: any): Promise<boolean>;
    mapItemFromDB(data: any): {
        dimensions: any;
        expires: any;
        metric: any;
        namespace: any;
        owner: any;
        seq: any;
        spans: any;
    };
    mapItemToDB(item: any): {
        [x: number]: any;
        spans: any;
        seq: any;
        _source: any;
    };
    roundTime(span: any, timestamp: any): number;
    assert(c: any): void;
    info(message: any, context?: {}): void;
    error(message: any, context?: {}): void;
    trace(message: any, context?: {}): void;
    round(n: any): number;
    jitter(msecs: any): number;
    delay(time: any): Promise<any>;
}
declare class Log {
    constructor(dest: any);
    senselogs: any;
    logger: any;
    verbose: boolean;
    error(message: any, context: any): void;
    info(message: any, context: any): void;
    trace(message: any, context: any): void;
    process(chan: any, message: any, context: any): void;
    defaultLogger(chan: any, message: any, context: any): void;
}
import { QueryCommand } from '@aws-sdk/client-dynamodb';
export {};
