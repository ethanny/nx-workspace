"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = exports.log = exports.dumpQuery = exports.dumpMetric = exports.dump = exports.delay = exports.DefaultSpans = exports.CustomMetrics = exports.client = exports.table = void 0;
const index_1 = require("../../src/index");
Object.defineProperty(exports, "CustomMetrics", { enumerable: true, get: function () { return index_1.CustomMetrics; } });
Object.defineProperty(exports, "DefaultSpans", { enumerable: true, get: function () { return index_1.DefaultSpans; } });
const senselogs_1 = __importDefault(require("senselogs"));
const log = new senselogs_1.default({ destination: 'stdout', format: 'human' });
exports.log = log;
/*
    Share the client and table created in setup.ts
 */
const client = globalThis.DynamoDBClient;
exports.client = client;
const table = globalThis.TableName;
exports.table = table;
//  Format date
function fmtdate(n) {
    function padTo2Digits(num) {
        return num.toString().padStart(2, '0');
    }
    let date = new Date(n);
    const year = date.getFullYear().toString().slice(-2); // Get last two digits of the year
    const month = padTo2Digits(date.getMonth() + 1); // Months are zero-indexed
    const day = padTo2Digits(date.getDate());
    const hours = padTo2Digits(date.getHours());
    const minutes = padTo2Digits(date.getMinutes());
    const seconds = padTo2Digits(date.getSeconds());
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
function dt(n) {
    return fmtdate(n * 1000);
}
const dump = (...args) => {
    let s = [];
    for (let item of args) {
        let values = JSON.stringify(item, function (key, value) {
            if (this[key] instanceof Date) {
                return fmtdate(this[key].getTime());
            }
            return value;
        }, 4);
        s.push(values);
    }
    let result = s.join(' ');
    console.log(result);
    return result;
};
exports.dump = dump;
const dumpMetric = function (metric) {
    let buf = [];
    buf.push(`${metric.namespace}/${metric.metric}/${JSON.stringify(metric.dimensions)}`);
    for (let span of metric.spans) {
        let interval = span.period / span.samples;
        let start = span.end - span.points.length * interval;
        buf.push(` ${span.period} secs ${fmtdate(start * 1000)} => ${fmtdate(span.end * 1000)} ${span.points.length} points`);
        for (let point of span.points) {
            buf.push(`     count ${point.count} = sum ${point.sum}`);
        }
    }
    print(buf.join('\n'));
};
exports.dumpMetric = dumpMetric;
const dumpQuery = function (metric) {
    let points = metric.points.slice(0);
    let buf = [];
    buf.push(`${metric.namespace}/${metric.metric}/${JSON.stringify(metric.dimensions)} ${metric.period} ${points.length} points`);
    for (let point of points) {
        buf.push(`     ${fmtdate(point.timestamp || 0)} = ${point.value || '-'} / ${point.count}`);
    }
    print(buf.join('\n'));
};
exports.dumpQuery = dumpQuery;
const print = (...args) => {
    console.log(...args);
};
exports.print = print;
globalThis.dt = dt;
globalThis.fmtdate = fmtdate;
globalThis.dump = dump;
globalThis.dumpMetric = dumpMetric;
globalThis.dumpQuery = dumpQuery;
globalThis.print = print;
const delay = async (time) => {
    return new Promise(function (resolve, reject) {
        setTimeout(() => resolve(true), time);
    });
};
exports.delay = delay;
